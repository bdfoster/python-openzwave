--- python-openzwave-20120828.orig/openzwave.pyx	2012-08-31 23:57:07.000000000 +0200
+++ python-openzwave-20120828/openzwave.pyx	2012-08-31 23:57:18.000000000 +0200
@@ -1,6 +1,31 @@
+""" This file is part of B{py-openzwave} project (U{https://github.com/maartendamen/py-openzwave}).
+
+License
+=======
+
+B{py-openzwave} is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+B{py-openzwave} is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with py-openzwave. If not, see U{http://www.gnu.org/licenses}.
+
+@author: maartendamen
+@author: bibi21000 <bibi21000@gmail.com>
+@license: GPL(v3)
+"""
+
 from cython.operator cimport dereference as deref
 from libcpp.map cimport map, pair
 
+PYLIBRARY = 0.1
+
 cdef extern from "<string>" namespace "std":
     cdef cppclass string:
         string()
@@ -13,9 +38,11 @@
     void free(void* ptr)
 
 ctypedef unsigned int uint32
+ctypedef unsigned long uint64
 ctypedef int int32
-ctypedef int int16
+ctypedef short int16
 ctypedef unsigned char uint8
+ctypedef signed char int8
 
 cdef extern from "Options.h" namespace "OpenZWave":
     cdef cppclass Options:
@@ -32,46 +59,55 @@
 
 cdef extern from "Notification.h" namespace "OpenZWave::Notification":
 
-    cdef enum NotificationType:
-        Type_ValueAdded = 0
-        Type_ValueRemoved = 1
-        Type_ValueChanged = 2
-        Type_Group = 3
-        Type_NodeNew = 4
-        Type_NodeAdded = 5
-        Type_NodeRemoved = 6
-        Type_NodeProtocolInfo = 7
-        Type_NodeNaming = 8
-        Type_NodeEvent = 9
-        Type_PollingDisabled = 10
-        Type_PollingEnabled = 11
-        Type_DriverReady = 12
-        Type_DriverReset = 13
-        Type_MsgComplete = 14
-        Type_NodeQueriesComplete = 15
-        Type_AwakeNodesQueried = 16
-        Type_AllNodesQueried = 17
+   cdef enum NotificationType:
+        Type_ValueAdded = 0                     # A new node value has been added to OpenZWave's list. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented.
+        Type_ValueRemoved = 1                   # A node value has been removed from OpenZWave's list.  This only occurs when a node is removed.
+        Type_ValueChanged = 2                   # A node value has been updated from the Z-Wave network and it is different from the previous value.
+        Type_ValueRefreshed = 3                 # A node value has been updated from the Z-Wave network.
+        Type_Group = 4                          # The associations for the node have changed. The application should rebuild any group information it holds about the node.
+        Type_NodeNew = 5                        # A new node has been found (not already stored in zwcfg*.xml file)
+        Type_NodeAdded = 6                      # A new node has been added to OpenZWave's list.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself.
+        Type_NodeRemoved = 7                    # A node has been removed from OpenZWave's list.  This may be due to a device being removed from the Z-Wave network, or because the application is closing.
+        Type_NodeProtocolInfo = 8               # Basic node information has been receievd, such as whether the node is a listening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description.
+        Type_NodeNaming = 9                     # One of the node names has changed (name, manufacturer, product).
+        Type_NodeEvent = 10                     # A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification.
+        Type_PollingDisabled = 11               # Polling of a node has been successfully turned off by a call to Manager::DisablePoll
+        Type_PollingEnabled = 12                # Polling of a node has been successfully turned on by a call to Manager::EnablePoll
+        Type_CreateButton = 13                  # Handheld controller button event created 
+        Type_DeleteButton = 14                  # Handheld controller button event deleted 
+        Type_ButtonOn = 15                      # Handheld controller button on pressed event
+        Type_ButtonOff = 16                     # Handheld controller button off pressed event 
+        Type_DriverReady = 17                   # A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods.
+        Type_DriverFailed = 18                  # Driver failed to load
+        Type_DriverReset = 19                   # All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications.
+        Type_MsgComplete = 20                   # The last message that was sent is now complete.
+        Type_EssentialNodeQueriesComplete = 21  # The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages.
+        Type_NodeQueriesComplete = 22           # All the initialisation queries on a node have been completed.
+        Type_AwakeNodesQueried = 23             # All awake nodes have been queried, so client application can expected complete data for these nodes.
+        Type_AllNodesQueried = 24               # All nodes have been queried, so client application can expected complete data.
+        Type_Error = 25                         # An error has occured that we need to report.
+
 
 cdef extern from "ValueID.h" namespace "OpenZWave":
 
     cdef enum ValueGenre:
-        ValueGenre_Basic = 0
-        ValueGenre_User = 1
-        ValueGenre_Config = 2
-        ValueGenre_System = 3
-        ValueGenre_Count = 4
+        ValueGenre_Basic = 0                # The 'level' as controlled by basic commands.  Usually duplicated by another command class.
+        ValueGenre_User = 1                 # Basic values an ordinary user would be interested in. 
+        ValueGenre_Config = 2               # Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead.
+        ValueGenre_System = 3               # Values of significance only to users who understand the Z-Wave protocol.
+        ValueGenre_Count = 4                # A count of the number of genres defined.  Not to be used as a genre itself.
 
     cdef enum ValueType:
-        ValueType_Bool = 0
-        ValueType_Byte = 1
-        ValueType_Decimal = 2
-        ValueType_Int = 3
-        ValueType_List = 4
-        ValueType_Schedule = 5
-        ValueType_Short = 6
-        ValueType_String = 7
-        ValueType_Button = 8
-        ValueType_Max = ValueType_Button
+        ValueType_Bool = 0                  # Boolean, true or false
+        ValueType_Byte = 1                  # 8-bit unsigned value
+        ValueType_Decimal = 2               # Represents a non-integer value as a string, to avoid floating point accuracy issues.
+        ValueType_Int = 3                   # 32-bit signed value
+        ValueType_List = 4                  # List from which one item can be selected
+        ValueType_Schedule = 5              # Complex type used with the Climate Control Schedule command class
+        ValueType_Short = 6                 # 16-bit signed value
+        ValueType_String = 7                # Text string
+        ValueType_Button = 8                # A write-only value that is the equivalent of pressing a button to send a command to a device
+        ValueType_Max = ValueType_Button    # The highest-number type defined.  Not to be used as a type itself.
 
     cdef cppclass ValueID:
         uint32 GetHomeId()
@@ -81,7 +117,7 @@
         uint8 GetInstance()
         uint8 GetIndex()
         ValueType GetType()
-        uint32 GetId()
+        uint64 GetId()
 
 cdef extern from "Notification.h" namespace "OpenZWave":
 
@@ -92,6 +128,8 @@
         ValueID& GetValueID()
         uint8 GetGroupIdx()
         uint8 GetEvent()
+        uint8 GetButtonId()
+        uint8 GetErrorCode()
         uint8 GetByte()
 
 ctypedef void (*pfnOnNotification_t)(const_notification _pNotification, void* _context )
@@ -111,17 +149,24 @@
         bint IsBridgeController(uint32 homeid)
         string GetLibraryVersion(uint32 homeid)
         string GetLibraryTypeName(uint32 homeid)
+        int32 GetSendQueueCount( uint32 homeId )
+        void LogDriverStatistics( uint32 homeId )
         # // Polling
         uint32 GetPollInterval()
-        void SetPollInterval(uint8 seconds)
-        bint EnablePoll(ValueID& valueId)
+        void SetPollInterval(uint32 milliseconds, bint bIntervalBetweenPolls)
+        bint EnablePoll(ValueID& valueId, uint8 intensity)
         bint DisablePoll(ValueID& valueId)
         bint isPolled(ValueID& valueId)
+        void SetPollIntensity( ValueID& valueId, uint8 intensity)
         # // Node Information
         bint RefreshNodeInfo(uint32 homeid, uint8 nodeid)
         void RequestNodeState(uint32 homeid, uint8 nodeid)
+        void RequestNodeDynamic( uint32 homeId, uint8 nodeId )
         bint IsNodeListeningDevice(uint32 homeid, uint8 nodeid)
+        bint IsNodeFrequentListeningDevice( uint32 homeId, uint8 nodeId )
+        bint IsNodeBeamingDevice( uint32 homeId, uint8 nodeId )
         bint IsNodeRoutingDevice(uint32 homeid, uint8 nodeid)
+        bint IsNodeSecurityDevice( uint32 homeId, uint8 nodeId )
         uint32 GetNodeMaxBaudRate(uint32 homeid, uint8 nodeid)
         uint8 GetNodeVersion(uint32 homeid, uint8 nodeid)
         uint8 GetNodeSecurity(uint32 homeid, uint8 nodeid)
@@ -156,7 +201,9 @@
         uint32 GetValueMin(ValueID& valueid)
         uint32 GetValueMax(ValueID& valueid)
         bint IsValueReadOnly(ValueID& valueid)
+        bint IsValueWriteOnly(ValueID& valueid)
         bint IsValueSet(ValueID& valueid)
+        bint IsValuePolled( ValueID& valueid )
         bint GetValueAsBool(ValueID& valueid, bint* o_value)
         bint GetValueAsByte(ValueID& valueid, uint8* o_value)
         bint GetValueAsFloat(ValueID& valueid, float* o_value)
@@ -173,19 +220,21 @@
         bint SetValue(ValueID& valueid, int16 value)
         bint SetValue(ValueID& valueid, string value)
         bint SetValueListSelection(ValueID& valueid, string selecteditem)
+        bint RefreshValue(ValueID& valueid)
+        void SetChangeVerified(ValueID& valueid, bint verify)
         bint PressButton(ValueID& valueid)
         bint ReleaseButton(ValueID& valueid)
-        uint8 GetNumSwitchPoints(ValueID& valueid)
         # // Climate Control
+        uint8 GetNumSwitchPoints(ValueID& valueid)
         bint SetSwitchPoint(ValueID& valueid, uint8 hours, uint8 minutes, uint8 setback)
         bint RemoveSwitchPoint(ValueID& valueid, uint8 hours, uint8 minutes)
         bint ClearSwitchPoints(ValueID& valueid)
-        bint GetSwitchPoint(ValueID& valueid, uint8 idx, uint8* o_hours, uint8* o_minutes, uint8* o_setback)
+        bint GetSwitchPoint(ValueID& valueid, uint8 idx, uint8* o_hours, uint8* o_minutes, int8* o_setback)
         # // SwitchAll
         void SwitchAllOn(uint32 homeid)
         void SwitchAllOff(uint32 homeid)
         # // Configuration Parameters
-        bint SetConfigParam(uint32 homeid, uint8 nodeid, uint8 param, uint32 value)
+        bint SetConfigParam(uint32 homeid, uint8 nodeid, uint8 param, uint32 value, uint8 size = 2)
         void RequestConfigParam(uint32 homeid, uint8 nodeid, uint8 aram)
         void RequestAllConfigParams(uint32 homeid, uint8 nodeid)
         # // Groups
@@ -202,6 +251,41 @@
         void SoftReset(uint32 homeid)
         #bint BeginControllerCommand(uint32 homeid, Driver::ControllerCommand _command, Driver::pfnControllerCallback_t _callback = NULL, void* _context = NULL, bool _highPower = false, uint8 _nodeId = 0xff )
         bint CancelControllerCommand(uint32 homeid)
+        # // Scene commands
+        uint8 GetNumScenes()
+        uint8 GetAllScenes(uint8** sceneIds)
+        uint8 CreateScene()
+        bint RemoveScene(uint8 sceneId)
+        bint AddSceneValue( uint8 sceneId, ValueID& valueId, bint value)
+        bint AddSceneValue( uint8 sceneId, ValueID& valueId, uint8 value)
+        bint AddSceneValue( uint8 sceneId, ValueID& valueId, float value )
+        bint AddSceneValue( uint8 sceneId, ValueID& valueId, int32 value )
+        bint AddSceneValue( uint8 sceneId, ValueID& valueId, int16 value )
+        bint AddSceneValue( uint8 sceneId, ValueID& valueId, string value )
+        bint AddSceneValueListSelection( uint8 sceneId, ValueID& valueId, string value )
+        bint AddSceneValueListSelection( uint8 sceneId, ValueID& valueId, int32 value )
+        bint RemoveSceneValue( uint8 sceneId, ValueID& valueId )
+        #int SceneGetValues( uint8 sceneId, vector<ValueID>* o_value )
+        bint SceneGetValueAsBool( uint8 sceneId, ValueID& valueId, bint value )
+        bint SceneGetValueAsByte( uint8 sceneId, ValueID& valueId, uint8* o_value )
+        bint SceneGetValueAsFloat( uint8 sceneId, ValueID& valueId, float* o_value )
+        bint SceneGetValueAsInt( uint8 sceneId, ValueID& valueId, int32* o_value )
+        bint SceneGetValueAsShort( uint8 sceneId, ValueID& valueId, int16* o_value )
+        bint SceneGetValueAsString( uint8 sceneId, ValueID& valueId, string* o_value )
+        bint SceneGetValueListSelection( uint8 sceneId, ValueID& valueId, string* o_value )
+        bint SceneGetValueListSelection( uint8 sceneId, ValueID& valueId, int32* o_value )
+        bint SetSceneValue( uint8 sceneId, ValueID& valueId, bint value )
+        bint SetSceneValue( uint8 sceneId, ValueID& valueId, uint8 value )
+        bint SetSceneValue( uint8 sceneId, ValueID& valueId, float value )
+        bint SetSceneValue( uint8 sceneId, ValueID& valueId, int32 value )
+        bint SetSceneValue( uint8 sceneId, ValueID& valueId, int16 value )
+        bint SetSceneValue( uint8 sceneId, ValueID& valueId, string value )
+        bint SetSceneValueListSelection( uint8 sceneId, ValueID& valueId, string value )
+        bint SetSceneValueListSelection( uint8 sceneId, ValueID& valueId, int32 value )
+        string GetSceneLabel( uint8 sceneId )
+        void SetSceneLabel( uint8 sceneId, string value )
+        bint SceneExists( uint8 sceneId )
+        bint ActivateScene( uint8 sceneId )
 
 cdef extern from "Manager.h" namespace "OpenZWave::Manager":
     Manager* Create()
@@ -223,40 +307,31 @@
 
 PyNotifications = [
     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's list. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),
-    EnumWithDoc('ValueRemoved').setDoc(
-                         "A node value has been removed from OpenZWave's list.  This only occurs when a node is removed."),
-    EnumWithDoc('ValueChanged').setDoc(
-                         "A node value has been updated from the Z-Wave network."),
-    EnumWithDoc('Group').setDoc(
-                         "The associations for the node have changed. The application should rebuild any group information it holds about the node."),
-    EnumWithDoc('NodeNew').setDoc(
-                         "A new node has been found (not already stored in zwcfg*.xml file)"),
-    EnumWithDoc('NodeAdded').setDoc(
-                         "A new node has been added to OpenZWave's list.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
-    EnumWithDoc('NodeRemoved').setDoc(
-                         "A node has been removed from OpenZWave's list.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
-    EnumWithDoc('NodeProtocolInfo').setDoc(
-                         "Basic node information has been receievd, such as whether the node is a listening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
-    EnumWithDoc('NodeNaming').setDoc(
-                         "One of the node names has changed (name, manufacturer, product)."),
-    EnumWithDoc('NodeEvent').setDoc(
-                         "A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
-    EnumWithDoc('PollingDisabled').setDoc(
-                         "Polling of a node has been successfully turned off by a call to Manager::DisablePoll"),
-    EnumWithDoc('PollingEnabled').setDoc(
-                         "Polling of a node has been successfully turned on by a call to Manager::EnablePoll"),
-    EnumWithDoc('DriverReady').setDoc(
-                         "A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
-    EnumWithDoc('DriverReset').setDoc(
-                         "All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
-    EnumWithDoc('MsgComplete').setDoc(
-                         "The last message that was sent is now complete."),
-    EnumWithDoc('NodeQueriesComplete').setDoc(
-                         "The initialisation queries on a node have been completed."),
-    EnumWithDoc('AwakeNodesQueried').setDoc(
-                         "All awake nodes have been queried, so client application can expected complete data for these nodes."),
-    EnumWithDoc('AllNodesQueried').setDoc(
-                         "All nodes have been queried, so client application can expected complete data."),
+    EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's list.  This only occurs when a node is removed."),
+    EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
+    EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
+    EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
+    EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
+    EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's list.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
+    EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's list.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
+    EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a listening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
+    EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
+    EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
+    EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
+    EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
+    EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
+    EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
+    EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
+    EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
+    EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
+    EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
+    EnumWithDoc('riverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
+    EnumWithDoc('MsgComplete').setDoc("The last message that was sent is now complete."),
+    EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
+    EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
+    EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
+    EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
+    EnumWithDoc('Error').setDoc("An error has occured that we need to report."),
     ]
 
 PyGenres = [
@@ -278,7 +353,7 @@
     EnumWithDoc('Button').setDoc(   "A write-only value that is the equivalent of pressing a button to send a command to a device"),
     ]
 
-cdef map[uint32, ValueID] values_map 
+cdef map[uint64, ValueID] values_map 
 
 cdef addValueId(ValueID v, n):
     cdef string value
@@ -302,7 +377,7 @@
                     'readOnly': manager.IsValueReadOnly(v),
                     }   
     
-    values_map.insert ( pair[uint32, ValueID] (v.GetId(), v)) 
+    values_map.insert ( pair[uint64, ValueID] (v.GetId(), v)) 
 
 cdef void callback(const_notification _notification, void* _context) with gil:
     cdef Notification* notification = <Notification*>_notification
@@ -608,6 +683,14 @@
         cdef string c_string = self.manager.GetLibraryVersion(homeid)
         return c_string.c_str()
 
+    def getPythonLibraryVersion(self):
+        '''
+Get the version of the python library.
+
+@return a string containing the python library version. For example, "0.1".
+        '''
+        return str(PYLIBRARY)
+
     def getLibraryTypeName(self, homeid):
         '''
 Get a string containing the Z-Wave API library type used by a controller.
@@ -632,6 +715,25 @@
         '''
         cdef string c_string = self.manager.GetLibraryTypeName(homeid)
         return c_string.c_str()
+
+    def getSendQueueCount(self, homeid):
+        '''
+Get count of messages in the outgoing send queue.
+
+@param homeId The Home ID of the Z-Wave controller.
+@return a integer message count
+        '''
+        return self.manager.GetSendQueueCount(homeid)
+
+    def logDriverStatistics(self, homeid):
+        '''
+Send current driver statistics to the log file.
+
+@param homeId The Home ID of the Z-Wave controller.
+@return a integer message count
+        '''
+        self.manager.LogDriverStatistics(homeid)
+
 #
 # -----------------------------------------------------------------------------
 # Polling Z-Wave devices
@@ -641,10 +743,12 @@
 # detect status changes.
 #
     def getPollInterval(self):
-        '''Get the time period between polls of a nodes state'''
+        '''
+Get the time period between polls of a nodes state
+        '''
         return self.manager.GetPollInterval()
 
-    def setPollInterval(self, seconds):
+    def setPollInterval(self, milliseconds, bIntervalBetweenPolls ):
         '''
 Set the time period between polls of a nodes state.
 
@@ -657,13 +761,59 @@
 set shorter than the number of polled devices in seconds (so that the network
 does not have to cope with more than one poll per second).
 
-@param seconds The length of the polling interval in seconds.
+@param milliseconds The length of the polling interval in milliseconds.
+@param bIntervalBetweenPolls Don't know what it is.
+        '''
+        self.manager.SetPollInterval(milliseconds, bIntervalBetweenPolls)
+
+    def enablePoll(self, id, intensity):
+        '''
+Enable the polling of a device's state.
+
+@param id the ID of a value.
+@param intensity the intensity of the poll
+@return True if polling was enabled.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.EnablePoll(values_map.at(id), intensity)
+        else :
+            return False
+
+    def disablePoll(self, id):
         '''
-        self.manager.SetPollInterval(seconds)
+Disable the polling of a device's state.
+
+@param id the ID of a value.
+@return True if polling was disabled.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.DisablePoll(values_map.at(id))
+        else :
+            return False
+
+    def isPolled(self, id):
+        '''
+Determine the polling of a device's state.
+
+@param id the ID of a value.
+@return True if polling is active.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.isPolled(values_map.at(id))
+        else :
+            return False
+
+    def setPollIntensity(self, id, intensity):
+        '''
+Set the frequency of polling (0=none, 1=every time through the list, 2-every other time, etc)
+
+@param id the ID of a value.
+@param intensity the intensity of the poll
+@return True if polling is active.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            self.manager.SetPollIntensity(values_map.at(id), intensity)
 
-#        bint EnablePoll(ValueID& valueId)
-#        bint DisablePoll(ValueID& valueId)
-#        bint isPolled(ValueID& valueId)
 #
 # -----------------------------------------------------------------------------
 # Node information
@@ -796,6 +946,7 @@
         '''
 Retrieve a list of neighbor node ids
 
+
 @param homeId The Home ID of the Z-Wave controller that manages the node.
 @param nodeId The ID of the node to query.
 @return A tuple containing neighboring node IDs
@@ -806,11 +957,12 @@
         # return value is pointer to uint8[]
         cdef uint32 count = self.manager.GetNodeNeighbors(homeid, nodeid, dbuf)
         cdef uint8* p
+        cdef uint32 start = 0
         if count:
             try:
                 data = set()
                 p = dbuf[0] # p is now pointing at first element of array
-                for i in range(0, count):
+                for i in range(start, count):
                     data.add(p[0])
                     p += 1
                 retval = tuple(data)
@@ -1123,6 +1275,10 @@
 if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
 @param id the ID of a value.
 @param value the value to set
+@return an integer representing the result of the operation 
+    0 : The C method fails
+    1 : The C method succeed
+    2 : Can't find id in the map
         '''
         cdef float type_float
         cdef bint type_bool
@@ -1130,40 +1286,180 @@
         cdef int32 type_int
         cdef int16 type_short
         cdef string type_string
-
+        ret = 2
         if values_map.find(id) != values_map.end(): 
             datatype = PyValueTypes[values_map.at(id).GetType()]
             
             if datatype == "Bool":
                 type_bool = value
-                self.manager.SetValue(values_map.at(id), type_bool)
+                cret = self.manager.SetValue(values_map.at(id), type_bool)
+                ret = 1 if cret else 0
             elif datatype == "Byte":
                 type_byte = value
-                self.manager.SetValue(values_map.at(id), type_byte)            
+                cret = self.manager.SetValue(values_map.at(id), type_byte)            
+                ret = 1 if cret else 0
             elif datatype == "Decimal":
                 type_float = value
-                self.manager.SetValue(values_map.at(id), type_float)
-            # TODO: this gives me an "ambiguous overloaded method", I don't understand why.
-            #elif datatype == "Int":
-            #    type_int = value
-            #    self.manager.SetValue(values_map.at(id), type_int)
-            #elif datatype == "Short":
-            #    type_short = value
-            #    self.manager.SetValue(values_map.at(id), type_short)
+                cret = self.manager.SetValue(values_map.at(id), type_float)
+                ret = 1 if cret else 0
+            elif datatype == "Int":
+                type_int = value
+                cret = self.manager.SetValue(values_map.at(id), type_int)
+                ret = 1 if cret else 0
+            elif datatype == "Short":
+                type_short = value
+                cret = self.manager.SetValue(values_map.at(id), type_short)
+                ret = 1 if cret else 0
             elif datatype == "String":
                 type_string = string(value)
-                self.manager.SetValue(values_map.at(id), type_string)
-                
-#        string GetValueLabel(ValueID& valueid)
-#        void SetValueLabel(ValueID& valueid, string value)
-#        string GetValueUnits(ValueID& valueid)
-#        void SetValueUnits(ValueID& valueid, string value)
-#        string GetValueHelp(ValueID& valueid)
-#        void SetValueHelp(ValueID& valueid, string value)
-#        uint32 GetValueMin(ValueID& valueid)
-#        uint32 GetValueMax(ValueID& valueid)
-#        bint IsValueReadOnly(ValueID& valueid)
-#        bint IsValueSet(ValueID& valueid)
+                cret = self.manager.SetValue(values_map.at(id), type_string)
+                ret = 1 if cret else 0
+        return ret
+
+    def refreshValue(self, id):
+        '''
+Refreshes the specified value from the Z-Wave network.
+A call to this function causes the library to send a message to the network to retrieve the current value
+of the specified ValueID (just like a poll, except only one-time, not recurring).
+
+@param id The unique identifier of the value to be refreshed.
+@return true if the driver and node were found; false otherwise
+        '''
+        return bool(self.manager.RefreshValue(values_map.at(id)))
+
+    def getValueLabel(self, id):
+        '''
+Gets the user-friendly label for the value
+
+@param id the ID of a value.
+@return A string containing the user-friendly label of the value
+        '''
+        cdef string c_string
+        if values_map.find(id) != values_map.end(): 
+            c_string = self.manager.GetValueLabel(values_map.at(id))
+            return c_string.c_str()
+        else :
+            return None
+              
+    def setValueLabel(self, id, char *label):
+        '''
+Sets the user-friendly label for the value
+
+@param id the ID of a value.
+@param label the label of the value.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            self.manager.SetValueLabel(values_map.at(id), string(label))
+
+    def getValueUnits(self, id):
+        '''
+Gets the units that the value is measured in.
+
+@param id the ID of a value.
+@return A string containing the value of the units.
+        '''
+        cdef string c_string
+        if values_map.find(id) != values_map.end(): 
+            c_string = self.manager.GetValueUnits(values_map.at(id))
+            return c_string.c_str()
+        else :
+            return None
+              
+    def setValueUnits(self, id, char *unit):
+        '''
+Sets the units that the value is measured in.
+
+@param id the ID of a value.
+@param label The new value of the units.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            self.manager.SetValueUnits(values_map.at(id), string(unit))
+
+    def getValueHelp(self, id):
+        '''
+Gets a help string describing the value's purpose and usage.
+
+@param id the ID of a value.
+@return A string containing the value help text.
+        '''
+        cdef string c_string
+        if values_map.find(id) != values_map.end(): 
+            c_string = self.manager.GetValueHelp(values_map.at(id))
+            return c_string.c_str()
+        else :
+            return None
+              
+    def setValueHelp(self, id, char *help):
+        '''
+Sets a help string describing the value's purpose and usage.
+
+@param id the ID of a value.
+@param label The new value of the help text.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            self.manager.SetValueHelp(values_map.at(id), string(help))
+
+    def getValueMin(self, id):
+        '''
+Gets the minimum that this value may contain.
+
+@param id the ID of a value.
+@return The value minimum.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.GetValueMin(values_map.at(id))
+        else :
+            return None
+
+    def getValueMax(self, id):
+        '''
+Gets the maximum that this value may contain.
+
+@param id the ID of a value.
+@return The value maximum.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.GetValueMax(values_map.at(id))
+        else :
+            return None
+
+    def isValueReadOnly(self, id):
+        '''
+Test whether the value is read-only.
+
+@param id the ID of a value.
+@return true if the value cannot be changed by the user.	
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.IsValueReadOnly(values_map.at(id))
+        else :
+            return None
+
+    def isValueWriteOnly(self, id):
+        '''
+Test whether the value is write-only.
+
+@param id the ID of a value.
+@return true if the value can only be written to and not read.	
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.IsValueWriteOnly(values_map.at(id))
+        else :
+            return None
+
+    def isValueSet(self, id):
+        '''
+Test whether the value has been set.
+
+@param id the ID of a value.
+@return true if the value has actually been set by a status message 
+from the device, rather than simply being the default.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.IsValueSet(values_map.at(id))
+        else :
+            return None
+
 #        bint GetValueAsBool(ValueID& valueid, bint* o_value)
 #        bint GetValueAsByte(ValueID& valueid, uint8* o_value)
 #        bint GetValueAsFloat(ValueID& valueid, float* o_value)
@@ -1175,12 +1471,44 @@
 #        bint GetValueListItems(ValueID& valueid, vector<string>* o_value)
 #        bint SetValue(ValueID& valueid, uint8 value)
 #        bint SetValue(ValueID& valueid, float value)
-#        bint SetValue(ValueID& valueid, uint32 value)
+#        bint SetValue(ValueID& valueid, uint16 value)
 #        bint SetValue(ValueID& valueid, uint32 value)
 #        bint SetValue(ValueID& valueid, string value)
 #        bint SetValueListSelection(ValueID& valueid, string selecteditem)
-#        bint PressButton(ValueID& valueid)
-#        bint ReleaseButton(ValueID& valueid)
+
+    def pressButton(self, id):
+        '''
+Starts an activity in a device.
+Since buttons are write-only values that do not report a state, 
+no notification callbacks are sent.
+
+@param id the ID of an integer value.
+@return true if the activity was started.  
+Returns false if the value is not a ValueID::ValueType_Button. 
+The type can be tested with a call to ValueID::GetType.
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.PressButton(values_map.at(id))
+        else :
+            return False
+
+    def releaseButton(self, id):
+        '''
+Stops an activity in a device.
+Since buttons are write-only values that do not report a state, 
+no notification callbacks are sent.
+
+@param id the ID of an integer value.
+@return true if the activity was stopped.  
+Returns false if the value is not a ValueID::ValueType_Button. 
+The type can be tested with a call to ValueID::GetType.
+
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.ReleaseButton(values_map.at(id))
+        else :
+            return False
+
 #
 # -----------------------------------------------------------------------------
 # Climate Control Schedules
@@ -1196,11 +1524,88 @@
 # The switch point methods only modify OpenZWave's copy of the schedule information.  Once all changes
 # have been made, they are sent to the device by calling SetSchedule.
 #
-#        bint SetSwitchPoint(ValueID& valueid, uint8 hours, uint8 minutes, uint8 setback)
-#        bint RemoveSwitchPoint(ValueID& valueid, uint8 hours, uint8 minutes)
-#        bint ClearSwitchPoints(ValueID& valueid)
-#        bint GetSwitchPoint(ValueID& valueid, uint8 idx, uint8* o_hours, uint8* o_minutes, uint8* o_setback)
-#        uint8 GetNumSwitchPoints(ValueID& valueid)
+    def setSwitchPoint(self, id, hours, minutes, setback):
+        '''
+Set a switch point in the schedule.
+
+@param id the ID of a value.
+@param hours
+@param minutes
+@param setback
+@return true if the switch point is set.
+
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.SetSwitchPoint(values_map.at(id), hours, minutes, setback)
+        else :
+            return False
+
+    def removeSwitchPoint(self, id, hours, minutes):
+        '''
+Remove a switch point from the schedule
+
+@param id the ID of a value.
+@param hours
+@param minutes
+@return true if the switch point is removed.
+
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.RemoveSwitchPoint(values_map.at(id), hours, minutes)
+        else :
+            return False
+
+    def clearSwitchPoints(self, id):
+        '''
+Clears all switch points from the schedule
+
+@param id the ID of a value.
+@return true if all switch points are clear.
+
+        '''
+        if values_map.find(id) != values_map.end(): 
+            self.manager.ClearSwitchPoints(values_map.at(id))
+
+    def getSwitchPoint(self, id, idx, hours, minutes, setback):
+        '''
+Gets switch point data from the schedule
+
+@param id the ID of a value.
+@param idx
+@param hours
+@param minutes
+@param setback
+@return true if data is retrieved.
+
+        '''
+        cdef uint8 ohours
+        cdef uint8 ominutes
+        cdef int8 osetback
+        if values_map.find(id) != values_map.end(): 
+            ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \
+                &ohours, &ominutes, &osetback)
+            if ret :
+                hours = ohours
+                minutes = ominutes
+                setback = osetback
+            return ret
+        else :
+            return False
+#        return False
+
+    def getNumSwitchPoints(self, id):
+        '''
+Get the number of switch points defined in a schedule
+
+@param id the ID of a value.
+@return the number of switch points.
+
+        '''
+        if values_map.find(id) != values_map.end(): 
+            return self.manager.GetNumSwitchPoints(values_map.at(id))
+        else :
+            return 0
+
 #
 # -----------------------------------------------------------------------------
 # SwitchAll
@@ -1326,11 +1731,12 @@
         # return value is pointer to uint8[]
         cdef uint32 count = self.manager.GetAssociations(homeid, nodeid, groupidx, dbuf)
         cdef uint8* p
+        cdef uint32 start = 0
         if count:
             try:
                 data = set()
                 p = dbuf[0] # p is now pointing at first element of array
-                for i in range(0, count):
+                for i in range(start, count):
                     data.add(p[0])
                     p += 1
                 retval = tuple(data)
@@ -1468,3 +1874,201 @@
 @see beginControllerCommand
         '''
         return self.manager.CancelControllerCommand(homeid)
+
+    def getNumScenes(self):
+        '''
+Gets the number of scenes that have been defined
+
+@return The number of scenes.
+@see GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+       '''
+        return self.manager.GetNumScenes()
+
+    def getAllScenes(self):
+        '''
+Gets a list of all the SceneIds
+
+@return A tuple containing neighboring scene IDs
+@see GetNumScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        retval = None
+        # TODO: proper initialization of this pointer.  
+        # Underlying code creates new uint8[] at this address, 
+        # but segfaults if passed in value is null.  Boy, is my C rusty.
+        cdef uint8** dbuf = <uint8**>malloc(sizeof(uint8))
+        # return value is pointer to uint8[]
+        cdef uint32 count = self.manager.GetAllScenes(dbuf)
+        cdef uint8* p
+        cdef uint32 start = 0
+        if count:
+            try:
+                data = set()
+                p = dbuf[0] # p is now pointing at first element of array
+                for i in range(start, count):
+                    data.add(p[0])
+                    p += 1
+                retval = tuple(data)
+            finally:
+                # TODO: caller is responsible for deleting returned array via call to delete()
+                pass
+        return retval
+        
+    def createScene(self):
+        '''
+Create a new Scene passing in Scene ID
+
+@return Scene ID used to reference the scene. 0 is failure result.
+@see GetNumScenes, GetAllScenes, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+       '''
+        return self.manager.CreateScene()
+
+    def removeScene(self, homeid):
+        '''
+Remove an existing Scene.
+
+@param sceneId is an integer representing the unique Scene ID to be removed.
+@return True if scene was removed.
+@see GetNumScenes, GetAllScenes, CreateScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        return self.manager.RemoveScene(homeid)
+
+    def addSceneValue(self, uint8 sceneid, id, value):
+        '''
+Add a ValueID of value to an existing scene.
+
+Actually I don't know how to use it. So do nothing.
+
+@param sceneId the ID of a scene.
+@param valueId the ID of a value.
+@param value the value to set
+@return an integer representing the result of the operation 
+    0 : The C method fails
+    1 : The C method succeed
+    2 : Can't find id in the map
+@see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        cdef float type_float
+        cdef bint type_bool
+        cdef uint8 type_byte
+        cdef int32 type_int
+        cdef int16 type_short
+        cdef string type_string
+        ret = 2
+        if values_map.find(id) != values_map.end(): 
+            datatype = PyValueTypes[values_map.at(id).GetType()]            
+            if datatype == "Bool":
+                type_bool = value
+                cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
+                ret = 1 if cret else 0
+            elif datatype == "Byte":
+                type_byte = value
+                cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)            
+                ret = 1 if cret else 0
+            elif datatype == "Decimal":
+                type_float = value
+                cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
+                ret = 1 if cret else 0
+            elif datatype == "Int":
+                type_int = value
+                cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
+                ret = 1 if cret else 0
+            elif datatype == "Short":
+                type_short = value
+                cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
+                ret = 1 if cret else 0
+            elif datatype == "String":
+                type_string = string(value)
+                cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
+                ret = 1 if cret else 0
+        return ret
+        
+    def setSceneValue(self, uint8 sceneid, id, value):
+        '''
+Set a value to an existing scene's ValueID.
+
+@param sceneId the ID of a scene.
+@param id the ID of a value.
+@param value the value to set
+@return an integer representing the result of the operation 
+    0 : The C method fails
+    1 : The C method succeed
+    2 : Can't find id in the map
+@see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        cdef float type_float
+        cdef bint type_bool
+        cdef uint8 type_byte
+        cdef int32 type_int
+        cdef int16 type_short
+        cdef string type_string
+        ret = 2
+        if values_map.find(id) != values_map.end(): 
+            datatype = PyValueTypes[values_map.at(id).GetType()]            
+            if datatype == "Bool":
+                type_bool = value
+                cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
+                ret = 1 if cret else 0
+            elif datatype == "Byte":
+                type_byte = value
+                cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)            
+                ret = 1 if cret else 0
+            elif datatype == "Decimal":
+                type_float = value
+                cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
+                ret = 1 if cret else 0
+            elif datatype == "Int":
+                type_int = value
+                cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
+                ret = 1 if cret else 0
+            elif datatype == "Short":
+                type_short = value
+                cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
+                ret = 1 if cret else 0
+            elif datatype == "String":
+                type_string = string(value)
+                cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
+                ret = 1 if cret else 0
+        return ret
+
+    def getSceneLabel(self, sceneid):
+        '''
+Returns a label for the particular scene.
+
+@param sceneId the ID of a scene.
+@param value the value to set
+@return The label string.
+@see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        cdef string c_string = self.manager.GetSceneLabel(sceneid)
+        return c_string.c_str()
+
+    def setSceneLabel(self, sceneid, char *label):
+        '''
+Sets a label for the particular scene.
+
+@param sceneId the ID of a scene.
+@param value The new value of the label.
+@see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        self.manager.SetSceneLabel(sceneid, string(label))
+        
+    def sceneExists(self, sceneid):
+        '''
+Check if a Scene ID is defined.
+
+@param sceneId the ID of a scene.
+@return true if Scene ID exists.
+@see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        return self.manager.SceneExists(sceneid)
+
+    def activateScene(self, sceneid):
+        '''
+Activate given scene to perform all its actions.
+
+@param sceneId the ID of a scene.
+@return true if it is successful.
+@see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
+        '''
+        return self.manager.ActivateScene(sceneid)
+
